#pragma once

#include "../core/types.h"
#include "cluster.h"

namespace nanite {

struct ClusterGroup {
    BoundingSphere bounds;             // enclosing sphere of all children
    BoundingSphere lodBounds;          // sphere used for LOD projected-error test
    float          parentLODError = 0.0f;  // max LOD error of parent level (monotonic)
    int32_t        mipLevel = 0;
    bool           isRoot = false;

    std::vector<uint32_t> children;    // cluster indices in ClusterDAG::clusters

    // Indices of parent clusters generated by reducing this group
    std::vector<uint32_t> parentClusters;
};

class ClusterDAG {
public:
    std::vector<Cluster>      clusters;
    std::vector<ClusterGroup> groups;
    AABB                      totalBounds;

    // Build the complete DAG from a raw mesh:
    // 1. Create leaf clusters
    // 2. Iteratively group, merge, simplify, split to build parent levels
    // 3. Until single root
    void build(const RawMesh& mesh);

    // Get indices of root groups
    std::vector<uint32_t> getRootGroupIndices() const;

    // Get cluster count per mip level (for stats)
    std::vector<uint32_t> getClusterCountPerLevel() const;

    // Get maximum mip level in the DAG
    int32_t getMaxMipLevel() const;

private:
    // Group clusters at one level using Morton-code spatial partitioning.
    // Returns indices of newly created groups.
    std::vector<uint32_t> groupClusters(const std::vector<uint32_t>& levelClusterIndices);

    // For one group: merge children, simplify, split into parent clusters.
    // Returns indices of newly created parent clusters.
    std::vector<uint32_t> reduceGroup(uint32_t groupIndex);
};

} // namespace nanite
