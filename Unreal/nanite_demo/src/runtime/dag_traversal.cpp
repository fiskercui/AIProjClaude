#include "dag_traversal.h"
#include <stack>

namespace nanite {

// Test AABB against frustum planes. Returns true if potentially visible.
static bool frustumTestAABB(const PackedView& view, const AABB& box) {
    for (int i = 0; i < 6; i++) {
        const glm::vec4& plane = view.frustumPlanes[i];
        // Find the "most positive" vertex relative to this plane
        glm::vec3 pVertex(
            plane.x > 0 ? box.max.x : box.min.x,
            plane.y > 0 ? box.max.y : box.min.y,
            plane.z > 0 ? box.max.z : box.min.z
        );
        if (glm::dot(glm::vec3(plane), pVertex) + plane.w < 0.0f) {
            return false; // entirely outside
        }
    }
    return true;
}

// Compute the projected error in pixels for a given LOD error at the sphere's distance.
//
// From UE5 NaniteClusterCulling.usf:
//   ProjectedEdgeScale = projected size of sphere at distance
//   Threshold = LODScale * parentLODError
//   Test: ProjectedEdgeScale <= Threshold
//
// Our simplified version:
//   projected_error_pixels = pixelsPerUnit * lodError
//   pixelsPerUnit = (0.5 * proj[1][1] * viewHeight) / depth
//   Accept coarse LOD if projected_error_pixels <= maxPixelsPerEdge
static float computeProjectedError(const PackedView& view, const BoundingSphere& sphere, float lodError) {
    // Transform sphere center to view space
    glm::vec4 viewPos = view.viewMatrix * glm::vec4(sphere.center, 1.0f);
    float z = -viewPos.z; // depth (positive into screen)

    if (z <= view.nearPlane * 0.5f) {
        // Very close or behind camera: force maximum refinement
        return 1e10f;
    }

    // pixels_per_unit * lodError = projected error in pixels
    float pixelsPerUnit = (0.5f * view.projMatrix[1][1] * (float)view.viewHeight) / z;
    return pixelsPerUnit * lodError;
}

void traverseDAG(
    const ClusterDAG& dag,
    const PackedView& view,
    std::vector<VisibleCluster>& outVisible,
    TraversalStats& outStats)
{
    outVisible.clear();
    outStats = {};

    int32_t maxLevel = dag.getMaxMipLevel();
    outStats.clustersByLevel.resize(maxLevel + 1, 0);

    // Get root groups as starting points
    std::vector<uint32_t> rootGroups = dag.getRootGroupIndices();
    if (rootGroups.empty()) return;

    // Stack-based traversal of the group hierarchy
    std::stack<uint32_t> groupStack;
    for (uint32_t gi : rootGroups) {
        groupStack.push(gi);
    }

    while (!groupStack.empty()) {
        uint32_t gi = groupStack.top();
        groupStack.pop();

        const ClusterGroup& group = dag.groups[gi];
        outStats.totalClustersVisited += (uint32_t)group.children.size();

        // LOD Decision:
        // Compute the projected error (in pixels) if we use the parent clusters.
        // parentLODError = max geometric error introduced by simplification at this level.
        //
        // If projectedError <= maxPixelsPerEdge: parent level is detailed enough.
        // Otherwise: descend to finer children.
        float projectedError = computeProjectedError(view, group.lodBounds, group.parentLODError);
        bool useParentLevel;

        if (group.parentLODError <= 0.0f || group.parentClusters.empty()) {
            // No parent clusters or leaf level: must descend to children
            useParentLevel = false;
        } else {
            useParentLevel = (projectedError <= view.maxPixelsPerEdge);
        }

        if (useParentLevel) {
            // Render the parent clusters generated by this group (coarser LOD)
            for (uint32_t ci : group.parentClusters) {
                const Cluster& cluster = dag.clusters[ci];

                // Frustum cull
                if (!frustumTestAABB(view, cluster.bounds)) {
                    outStats.clustersFrustumCulled++;
                    continue;
                }

                outVisible.push_back({ ci, cluster.mipLevel });
                outStats.clustersSelected++;
                outStats.totalTriangles += cluster.numTris;
                if (cluster.mipLevel < (int32_t)outStats.clustersByLevel.size()) {
                    outStats.clustersByLevel[cluster.mipLevel]++;
                }
            }
        } else {
            // Need finer detail: process child clusters
            for (uint32_t ci : group.children) {
                const Cluster& cluster = dag.clusters[ci];

                // Frustum cull first
                if (!frustumTestAABB(view, cluster.bounds)) {
                    outStats.clustersFrustumCulled++;
                    continue;
                }

                // If this child cluster was produced by reducing a finer group,
                // descend into that group for further LOD evaluation.
                if (cluster.generatingGroupIndex != INVALID_INDEX) {
                    groupStack.push(cluster.generatingGroupIndex);
                } else {
                    // Leaf cluster: no finer level exists. Render it.
                    outVisible.push_back({ ci, cluster.mipLevel });
                    outStats.clustersSelected++;
                    outStats.totalTriangles += cluster.numTris;
                    if (cluster.mipLevel < (int32_t)outStats.clustersByLevel.size()) {
                        outStats.clustersByLevel[cluster.mipLevel]++;
                    }
                }
            }
        }
    }
}

} // namespace nanite
